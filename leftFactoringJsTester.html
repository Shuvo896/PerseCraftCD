<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Left Factoring Calculator</title>
</head>
<body>
    <h2>Left Factoring Calculator (Browser JS)</h2>

    <textarea id="inputBox" rows="10" cols="60" placeholder="Enter productions here..."></textarea>
    <br>
    <button onclick="runLeftFactoring()">Run</button>

    <h3>Output:</h3>
    <pre id="outputBox"></pre>

    <script>
        // Left Factoring Calculator in JavaScript
        // ASCII-safe, character-level CFG

        function leftFactorCalculator(inputText) {
            const EPS = "eps";  // internal epsilon

            // Utility: trim string
            function trim(s) {
                return s.replace(/^\s+|\s+$/g, '');
            }

            // Validate and parse a production line
            function parseProduction(line) {
                const arrow = line.indexOf("->");
                if (arrow === -1) throw "Missing '->' in: " + line;

                const lhs = trim(line.slice(0, arrow));
                const rhsText = trim(line.slice(arrow + 2));

                if (!/^[A-Z]$/.test(lhs))
                    throw "LHS must be a single uppercase letter (A-Z): " + lhs;

                const rhsParts = rhsText.split('|').map(trim);
                if (rhsParts.length === 0) throw "No RHS alternatives found";

                for (const p of rhsParts) {
                    if (p === "") throw "Empty RHS alternative found";

                    // Allow letters, digits, operators, parentheses, apostrophe
                    if (p !== "eps" && !/^[a-zA-Z0-9+\-*/%()']+$/.test(p))
                        throw "Invalid characters in RHS alternative: " + p;
                }

                return { lhs, rhs: rhsParts };
            }

            // Grammar structure: map LHS -> array of productions
            const grammar = {};

            const lines = inputText.split(/\r?\n/);
            for (const lineRaw of lines) {
                const line = trim(lineRaw);
                if (line === "" || line.toUpperCase() === "END") continue;

                const prod = parseProduction(line);
                grammar[prod.lhs] = prod.rhs;
            }

            // Counter for new non-terminals
            let counter = 0;
            function newNonTerminal() {
                counter++;
                return "X" + counter;
            }

            // Compute longest common prefix of multiple strings
            function longestCommonPrefix(strings) {
                if (strings.length === 0) return "";
                let prefix = strings[0];
                for (let s of strings.slice(1)) {
                    let i = 0;
                    while (i < prefix.length && i < s.length && prefix[i] === s[i]) i++;
                    prefix = prefix.slice(0, i);
                    if (prefix === "") break;
                }
                return prefix;
            }

            // Recursive left factoring
            function leftFactor(A) {
            let queue = [A];

            while (queue.length > 0) {
                const curr = queue.shift();
                const rules = grammar[curr];
                if (!rules || rules.length <= 1) continue;

                // Group rules by first character
                const groups = {};
                for (const r of rules) {
                    const key = r === EPS ? "#" : r[0];
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(r);
                }

                let changed = false;
                const newRules = [];

                for (const key in groups) {
                    const prods = groups[key];
                    if (prods.length <= 1) {
                        newRules.push(...prods);
                        continue;
                    }

                    const prefix = longestCommonPrefix(prods);
                    if (!prefix) {
                        newRules.push(...prods);
                        continue;
                    }

                    // Create new non-terminal
                    const newNT = newNonTerminal();
                    const newProds = [];

                    for (const p of prods) {
                        if (p === prefix) newProds.push(EPS);
                        else newProds.push(p.slice(prefix.length));
                    }

                    grammar[newNT] = newProds;
                    queue.push(newNT); // queue new non-terminal for factoring later

                    newRules.push(prefix + newNT);
                    changed = true;
                }

                grammar[curr] = newRules;
            }
        }


            // Perform left factoring for all non-terminals
            for (const A in grammar) leftFactor(A);

            // Format output
            let output = "";
            for (const A in grammar) {
                output += A + " -> ";
                output += grammar[A].map(p => p === EPS ? "eps" : p).join(" | ");
                output += "\n";
            }

            return output;
        }

        
        // Example wrapper function to connect UI:
        function runLeftFactoring() {
            const inputText = document.getElementById("inputBox").value;
            try {
                const result = leftFactorCalculator(inputText);
                document.getElementById("outputBox").textContent = result;
            } catch (err) {
                document.getElementById("outputBox").textContent = "Error: " + err;
            }
        }
    </script>
</body>
</html>
